{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "wheel-calender",
  "type": "registry:component",
  "title": "Wheel Calender",
  "description": "A wheel calender to select birthday.",
  "files": [
    {
      "path": "registry/default/persian-wheel-calender.tsx",
      "content": "\"use client\";\n\nimport { useState, useEffect, useRef, useCallback } from \"react\";\nimport dayjs, { Dayjs } from \"dayjs\";\nimport jalaliday from \"jalaliday\";\n\n// Enable Jalali calendar support once.\ndayjs.extend(jalaliday);\n\n/** Value passed to parent when the date changes. */\nexport type PickerChangeValue = { jalali: string; gregorian: string };\n\nexport interface IPersianWheelPickerProps {\n  /** Smallest selectable Jalali year (e.g. 1300). */\n  minYear?: number;\n  /** Largest selectable Jalali year (defaults to current Jalali year). */\n  maxYear?: number;\n  /** Initial Jalali date string (YYYY-MM-DD). */\n  initialJalaliDate?: string;\n  /** Debounced callback fired when user selects a new date. */\n  onChange?: (value: PickerChangeValue) => void;\n  /** Extra container classes. */\n  className?: string;\n  /** Number of visible rows (odd number >= 3) when `centered` is true. */\n  visibleRows?: number;\n  /** If true, adds top/bottom spacers so the selected item sits in the vertical center. */\n  centered?: boolean;\n}\n\n/** An individual option for a wheel. */\ninterface WheelItem {\n  value: number;\n  label: string;\n}\n\nconst faMonths: readonly string[] = [\n  \"فروردین\",\n  \"اردیبهشت\",\n  \"خرداد\",\n  \"تیر\",\n  \"مرداد\",\n  \"شهریور\",\n  \"مهر\",\n  \"آبان\",\n  \"آذر\",\n  \"دی\",\n  \"بهمن\",\n  \"اسفند\",\n] as const;\n\n/** Utility clamp. */\nconst clamp = (v: number, min: number, max: number): number =>\n  Math.max(min, Math.min(v, max));\n\n/**\n * Debounce helper that returns a *stable* function identity.\n * We keep the timer ref inside so callers don't need to manage it.\n */\nfunction useDebouncedCallback<T extends (...args: unknown[]) => void>(\n  cb: T,\n  delay = 150\n): (...args: Parameters<T>) => void {\n  const timerRef = useRef<number | null>(null);\n\n  return useCallback(\n    (...args: Parameters<T>) => {\n      if (timerRef.current) window.clearTimeout(timerRef.current);\n      timerRef.current = window.setTimeout(() => cb(...args), delay);\n    },\n    [cb, delay]\n  );\n}\n\n/** Props for a single scroll wheel UI. */\ninterface WheelProps {\n  items: WheelItem[];\n  /** Current selected value. */\n  value: number;\n  /** Called when wheel selection changes (while scrolling or after snap). */\n  onChange: (v: number) => void;\n  /** For accessibility. */\n  ariaLabel: string;\n  /** If true, use centered wheel with spacers. */\n  centered: boolean;\n  /** Number of rows to show when centered (must be odd). */\n  visibleRows: number;\n}\n\nconst ITEM_HEIGHT = 44; // px per row\n\n/**\n * Generic scroll wheel component used for day / month / year.\n * Implements inertial scroll + snapping with smooth UX even during fast flicks.\n */\nexport const Wheel: React.FC<WheelProps> = ({\n  items,\n  value,\n  onChange,\n  ariaLabel,\n  centered = false,\n  visibleRows = 5,\n}) => {\n  const containerRef = useRef<HTMLDivElement | null>(null);\n  const animationFrameRef = useRef<number | null>(null);\n  const snapTimeoutRef = useRef<number | null>(null);\n  const isUserScrollingRef = useRef(false);\n\n  const spacerCountEachSide = centered ? (visibleRows - 1) / 2 : 0;\n\n  /** Find index of current value in list. */\n  const findIndex = useCallback(\n    (v: number): number => items.findIndex((i) => i.value === v),\n    [items]\n  );\n\n  /**\n   * Programmatic scroll to a given index.\n   * We compute target differently for linear vs centered modes.\n   */\n  const scrollToIndex = useCallback(\n    (newIndex: number, behavior: ScrollBehavior = \"smooth\"): void => {\n      const el = containerRef.current;\n      if (!el) return;\n\n      const target = centered\n        ? newIndex * ITEM_HEIGHT\n        : items.length > 1\n        ? (newIndex / (items.length - 1)) * (el.scrollHeight - el.clientHeight)\n        : 0;\n\n      el.scrollTo({ top: target, behavior });\n    },\n    [centered, items]\n  );\n\n  /**\n   * Snap the wheel to the *nearest* item index,\n   * update selection if necessary, and animate to its precise offset.\n   */\n  const snapToClosest = useCallback(\n    (el: HTMLDivElement): void => {\n      const scrollTop = el.scrollTop;\n      const maxScrollTop = el.scrollHeight - el.clientHeight;\n\n      let index: number;\n      if (centered) {\n        index = Math.round(scrollTop / ITEM_HEIGHT);\n      } else {\n        index =\n          maxScrollTop <= 0\n            ? 0\n            : Math.round((scrollTop / maxScrollTop) * (items.length - 1));\n      }\n      index = clamp(index, 0, items.length - 1);\n\n      const newValue = items[index].value;\n      if (newValue !== value) onChange(newValue);\n\n      scrollToIndex(index, \"smooth\");\n    },\n    [centered, items, onChange, scrollToIndex, value]\n  );\n\n  /**\n   * After scroll events quiet down for 120ms, trigger snap.\n   * If user keeps scrolling, the timer resets.\n   */\n  const scheduleSnapToClosest = useCallback(\n    (el: HTMLDivElement): void => {\n      if (snapTimeoutRef.current) window.clearTimeout(snapTimeoutRef.current);\n      snapTimeoutRef.current = window.setTimeout(() => {\n        snapToClosest(el);\n        isUserScrollingRef.current = false;\n      }, 120);\n    },\n    [snapToClosest]\n  );\n\n  /**\n   * Scroll event handler:\n   *  - Marks user scrolling state\n   *  - Debounces a snap\n   *  - Schedules an rAF to emit intermediate selection changes\n   */\n  const handleScroll = useCallback(\n    (e: React.UIEvent<HTMLDivElement>): void => {\n      const el = e.currentTarget;\n      isUserScrollingRef.current = true;\n      scheduleSnapToClosest(el);\n\n      if (animationFrameRef.current)\n        cancelAnimationFrame(animationFrameRef.current);\n\n      animationFrameRef.current = requestAnimationFrame(() => {\n        const scrollTop = el.scrollTop;\n        const maxScrollTop = el.scrollHeight - el.clientHeight;\n\n        let index: number;\n        if (centered) {\n          index = Math.round(scrollTop / ITEM_HEIGHT);\n        } else {\n          index =\n            maxScrollTop <= 0\n              ? 0\n              : Math.round((scrollTop / maxScrollTop) * (items.length - 1));\n        }\n        index = clamp(index, 0, items.length - 1);\n\n        const newValue = items[index].value;\n        if (newValue !== value) onChange(newValue);\n      });\n    },\n    [centered, items, onChange, scheduleSnapToClosest, value]\n  );\n\n  /**\n   * Keep wheel visually in sync when parent changes `value` externally.\n   * We only scroll if the DOM position is meaningfully different and the user\n   * is not actively scrolling (prevents \"fighting\" their gesture).\n   */\n  useEffect(() => {\n    const ix = findIndex(value);\n    if (ix < 0 || !containerRef.current) return;\n\n    const el = containerRef.current;\n    const target = centered\n      ? ix * ITEM_HEIGHT\n      : items.length > 1\n      ? (ix / (items.length - 1)) * (el.scrollHeight - el.clientHeight)\n      : 0;\n\n    if (Math.abs(el.scrollTop - target) > 2 && !isUserScrollingRef.current) {\n      scrollToIndex(ix, \"smooth\");\n    }\n  }, [value, items, centered, findIndex, scrollToIndex]);\n\n  /** Clean up timers / rAF on unmount. */\n  useEffect(\n    () => () => {\n      if (animationFrameRef.current)\n        cancelAnimationFrame(animationFrameRef.current);\n      if (snapTimeoutRef.current) window.clearTimeout(snapTimeoutRef.current);\n    },\n    []\n  );\n\n  const containerStyle: React.CSSProperties = centered\n    ? { height: ITEM_HEIGHT * visibleRows }\n    : { height: ITEM_HEIGHT * 5.5 }; // arbitrary visible height for linear mode\n\n  return (\n    <div\n      className=\"relative flex flex-col items-stretch w-28\"\n      aria-label={ariaLabel}\n    >\n      <div\n        ref={containerRef}\n        className={[\n          \"overflow-y-scroll no-scrollbar focus:outline-none rounded-xl select-none relative scroll-smooth\",\n          centered ? \"scroll-py-0\" : \"\",\n        ].join(\" \")}\n        style={containerStyle}\n        tabIndex={0}\n        onScroll={handleScroll}\n        role=\"listbox\"\n        aria-activedescendant={`${ariaLabel}-option-${value}`}\n      >\n        <div className=\"relative\">\n          {centered && (\n            <div\n              style={{ height: ITEM_HEIGHT * spacerCountEachSide }}\n              aria-hidden\n            />\n          )}\n\n          {items.map((item) => (\n            <div\n              key={item.value}\n              id={`${ariaLabel}-option-${item.value}`}\n              role=\"option\"\n              aria-selected={item.value === value}\n              className={`h-[44px] flex items-center justify-center text-sm cursor-pointer transition-colors ${\n                item.value === value ? \"font-black !text-lg\" : \"rounded-md\"\n              }`}\n              style={{ scrollSnapAlign: centered ? undefined : \"start\" }}\n              onClick={() => {\n                const ix = findIndex(item.value);\n                if (item.value !== value) onChange(item.value);\n                // Only animate scroll if visual position differs.\n                const el = containerRef.current;\n                if (el) {\n                  const target = centered\n                    ? ix * ITEM_HEIGHT\n                    : items.length > 1\n                    ? (ix / (items.length - 1)) *\n                      (el.scrollHeight - el.clientHeight)\n                    : 0;\n                  if (Math.abs(el.scrollTop - target) > 1)\n                    scrollToIndex(ix, \"smooth\");\n                }\n              }}\n            >\n              {item.label}\n            </div>\n          ))}\n\n          {centered && (\n            <div\n              style={{ height: ITEM_HEIGHT * spacerCountEachSide }}\n              aria-hidden\n            />\n          )}\n        </div>\n      </div>\n\n      {/* Center highlight lines */}\n      {centered && (\n        <div\n          className=\"pointer-events-none absolute left-0 right-0 flex justify-center\"\n          style={{\n            top: `calc(50% - ${ITEM_HEIGHT / 2}px)`,\n            height: `${ITEM_HEIGHT}px`,\n          }}\n        >\n          <div className=\"w-full border-y\" />\n        </div>\n      )}\n    </div>\n  );\n};\n\n/** Renders formatted Jalali + Gregorian preview text. */\nconst SelectedDatePreview: React.FC<{\n  year: number;\n  month: number;\n  day: number;\n}> = ({ year, month, day }) => {\n  const jalaliStr = `${year}-${String(month).padStart(2, \"0\")}-${String(\n    day\n  ).padStart(2, \"0\")}`;\n\n  const gregorian = dayjs(jalaliStr, { jalali: true }).calendar(\"gregory\");\n  const formattedFa = dayjs(jalaliStr, { jalali: true })\n    .locale(\"fa\")\n    .calendar(\"jalali\")\n    .format(\"dddd D MMMM YYYY\");\n\n  return (\n    <div className=\"flex flex-col items-center gap-1 text-sm\">\n      <div>{formattedFa}</div>\n      <div className=\"text-xs\">({gregorian.format(\"YYYY-MM-DD\")})</div>\n    </div>\n  );\n};\n\n/**\n * Main composite component: three wheels (day / month / year) + preview.\n */\nconst PersianWheelPicker: React.FC<IPersianWheelPickerProps> = ({\n  minYear = 1300,\n  maxYear = dayjs().calendar(\"jalali\").year(),\n  initialJalaliDate,\n  onChange,\n  className = \"\",\n  centered = false,\n  visibleRows = 5,\n}) => {\n  // Resolve initial Jalali date.\n  const todayJalali = dayjs().calendar(\"jalali\");\n  let initial: Dayjs = todayJalali;\n\n  if (initialJalaliDate) {\n    const [y, m, d] = initialJalaliDate.split(\"-\").map(Number);\n    const parsed = dayjs()\n      .calendar(\"jalali\")\n      .year(y)\n      .month(m - 1)\n      .date(d);\n    if (parsed.isValid()) initial = parsed;\n  }\n\n  // Controlled state for each wheel.\n  const [year, setYear] = useState<number>(() =>\n    clamp(initial.year(), minYear, maxYear)\n  );\n  const [month, setMonth] = useState<number>(() => initial.month() + 1);\n  const [day, setDay] = useState<number>(() => initial.date());\n\n  // Days in current Jalali month (handles Esfand leap years).\n  const daysInMonth = dayjs()\n    .calendar(\"jalali\")\n    .year(year)\n    .month(month - 1)\n    .date(1)\n    .daysInMonth();\n\n  // Adjust day if month/year change makes it overflow.\n  useEffect(() => {\n    if (day > daysInMonth) setDay(daysInMonth);\n  }, [daysInMonth, day]);\n\n  // Build wheel item lists.\n  const yearItems: WheelItem[] = [];\n  for (let y = maxYear; y >= minYear; y--) {\n    yearItems.push({ value: y, label: y.toString() });\n  }\n\n  const monthItems: WheelItem[] = faMonths.map((m, i) => ({\n    value: i + 1,\n    label: m,\n  }));\n\n  const dayItems: WheelItem[] = Array.from({ length: daysInMonth }, (_, i) => ({\n    value: i + 1,\n    label: (i + 1).toString().padStart(2, \"0\"),\n  }));\n\n  /** Debounced emit to parent so rapid scroll doesn't spam. */\n  const emitChange = useDebouncedCallback(() => {\n    const jalaliStr = `${year}-${String(month).padStart(2, \"0\")}-${String(\n      day\n    ).padStart(2, \"0\")}`;\n    const gregorianIso = dayjs(jalaliStr, { jalali: true })\n      .calendar(\"gregory\")\n      .format(\"YYYY-MM-DD\");\n    onChange?.({ jalali: jalaliStr, gregorian: gregorianIso });\n  }, 150);\n\n  useEffect(() => {\n    emitChange();\n  }, [year, month, day, emitChange]);\n\n  return (\n    <div\n      dir=\"rtl\"\n      className={`flex flex-col gap-4 p-4 rounded-2xl w-full ${className}`}\n    >\n      <div className=\"flex justify-center\">\n        <Wheel\n          ariaLabel=\"day\"\n          items={dayItems}\n          value={day}\n          onChange={setDay}\n          centered={centered}\n          visibleRows={visibleRows}\n        />\n        <Wheel\n          ariaLabel=\"month\"\n          items={monthItems}\n          value={month}\n          onChange={setMonth}\n          centered={centered}\n          visibleRows={visibleRows}\n        />\n        <Wheel\n          ariaLabel=\"year\"\n          items={yearItems}\n          value={year}\n          onChange={setYear}\n          centered={centered}\n          visibleRows={visibleRows}\n        />\n      </div>\n\n      <SelectedDatePreview year={year} month={month} day={day} />\n\n      {/* Hide scrollbars for aesthetic wheel look. */}\n      <style jsx global>{`\n        .no-scrollbar::-webkit-scrollbar {\n          display: none;\n        }\n        .no-scrollbar {\n          -ms-overflow-style: none;\n          scrollbar-width: none;\n        }\n      `}</style>\n    </div>\n  );\n};\n\nexport default PersianWheelPicker;\n\n/**\n * Usage Example:\n *\n * const Example = () => {\n *   const handleDate = (val: { jalali: string; gregorian: string }) => {\n *     console.log('Selected date:', val);\n *   };\n *   return <PersianWheelPicker onChange={handleDate} centered visibleRows={5} />;\n * };\n *\n * Notes:\n *  - Install dependencies: `npm i dayjs jalaliday`\n *  - For TypeScript, add: `declare module 'jalaliday';` if needed.\n *  - Use `maxYear` / `minYear` to enforce age limits.\n *  - `centered` mode displays guiding lines and spacers.\n */\n",
      "type": "registry:component"
    }
  ]
}
